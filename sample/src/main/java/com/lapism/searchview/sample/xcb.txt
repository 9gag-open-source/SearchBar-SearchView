// testnotu textonly a voice na vyhledavani

NO DIVIDER
NO KEYBOARD IN LANDSCAPE MODE
FIX SEARCH BEHAVIOR and shadow under AppbarLayout
projit SEARCHVIEW
TODOS
CARDVIEW CLICK

PROJIT TO NA PLOSE
















android:outlineProvider="bounds"


<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <solid android:color="@color/white" />
            <stroke
                android:width="1dp"
                android:color="@color/grey"/>
        </shape>
    </item>
</selector>
but this does:

<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <shape android:shape="rectangle">
            <solid android:color="@color/white" />
            <corners android:radius="1dp" />
            <stroke
                android:width="1dp"
                android:color="@color/grey"/>
        </shape>
    </item>
</selector>
<android.support.v7.widget.CardView
    xmlns:card_view="http://schemas.android.com/apk/res-auto"
    card_view:cardElevation="4dp" />
<android.support.v7.widget.CardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:card_view="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="6dp"
    card_view:cardUseCompatPadding="true"
    card_view:cardElevation="4dp"
    card_view:cardCornerRadius="3dp">




private void setAppBarLayoutBehaviour() {
    AppBarLayout.Behavior behavior = new AppBarLayout.Behavior() {

        @Override
        public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View directTargetChild, View target, int nestedScrollAxes) {
            // Trigger the following events if it is a vertical scrolling
            return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);
        }

        @Override
        public void onNestedScroll(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) {
            super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);

            // If I slowly reach the top, without fling, show the RecyclerView
            int[] firstVisiblePositions = ((StaggeredGridLayoutManager) ((RecyclerView) target).getLayoutManager()).findFirstCompletelyVisibleItemPositions(null);
            for (int position : firstVisiblePositions) {
                if (position == 0) {
                    showRelatedTerms();
                    break;
                }
            }
        }

        @Override
        public boolean onNestedFling(CoordinatorLayout coordinatorLayout, AppBarLayout child, View target, float velocityX, float velocityY, boolean consumed) {
            if (velocityY > 500) {
                // Hide the RecyclerView
            } else if (velocityY < -500) {
                // Show the recyclerView
            }
            return true;
        }
    };
    ((CoordinatorLayout.LayoutParams) appBarLayout.getLayoutParams()).setBehavior(behavior);
}
<android.support.design.widget.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="300dp"
        android:fitsSystemWindows="true"
        android:stateListAnimator="@animator/appbar_always_elevated"
        android:theme="@style/AppTheme.AppBarOverlay">

</android.support.design.widget.AppBarLayout>

<android.support.design.widget.AppBarLayout
    android:stateListAnimator="@null"
    android:elevation="@dimen/design_appbar_elevation">


ActionBar actionBar = getSupportActionBar();
if(actionBar != null) {
   actionBar.setElevation(0);
}

if(getSupportActionBar() != null) {
    getSupportActionBar().setElevation(0);
}

// Boolean, boolean
// ANALYZE, TODO, FIXME
// file:///E:/Android/SearchView/sample/build/outputs/lint-results-debug.html
// file:///E:/Android/SearchView/searchview/build/outputs/lint-results-debug.html

/*
SPAN_EXCLUSIVE_EXCLUSIVE spans cannot have a zero length
RecyclerView does not support scrolling to an absolute position. Use scrollToPosition instead
beginBatchEdit on inactive InputConnection
getSelectedText on inactive InputConnection
endBatchEdit on inactive InputConnection
getTextBeforeCursor on inactive InputConnection
getTextAfterCursor on inactive InputConnection
No adapter attached; skipping layout
*/

// s.removeSpan(new ForegroundColorSpan(SearchView.getTextColor()));
// viewHolder.text.setText(s, TextView.BufferType.SPANNABLE);getContext();
// @ColorRes, Filter.FilterListener
// mRecyclerView.setAlpha(0.0f);
// mRecyclerView.animate().alpha(1.0f);

/*Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
@Override
public void run() {
        getViewLayout().setVisibility(View.VISIBLE);
        getViewLayout().setBackgroundColor(getPrimaryColor());
        }
        },1000);*/






/*private Runnable mReleaseCursorRunnable = new Runnable() {
    @Override
    public void run() {
        if (mSuggestionsAdapter != null) {
            mSuggestionsAdapter.changeCursor(null);
        }
    }
};*/

//private final WeakHashMap<String, Drawable.ConstantState> mOutsideDrawablesCache = new WeakHashMap<String, Drawable.ConstantState>();

/*
        mVoiceWebSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);

        mVoiceAppSearchIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);*/

/*

    public void setQuery(CharSequence query) {
        mSearchSrcTextView.setText(query);
        if (query != null) {
            mSearchSrcTextView.setSelection(mSearchSrcTextView.length());
            mUserQuery = query;
        }

        if (!TextUtils.isEmpty(query)) {
            onSubmitQuery();
        }
    }


    private void updateVoiceButton(boolean empty) {
        int visibility = GONE;
        if (mVoiceButtonEnabled && empty) {
            visibility = VISIBLE;
            mGoButton.setVisibility(GONE);
        }
        mVoiceButton.setVisibility(visibility);
    }

    void onSubmitQuery() {
        CharSequence query = mSearchSrcTextView.getText();
        if (query != null && TextUtils.getTrimmedLength(query) > 0) {
            if (mOnQueryChangeListener == null || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) {
                if (mSearchable != null) {
                    launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString());
                }
            }
        }
    }


    static class SavedState extends AbsSavedState {
        boolean isIconified;

        SavedState(Parcelable superState) {
            super(superState);
        }

        public SavedState(Parcel source, ClassLoader loader) {
            super(source, loader);
            isIconified = (Boolean) source.readValue(null);
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            super.writeToParcel(dest, flags);
            dest.writeValue(isIconified);
        }

        @Override
        public String toString() {
            return "SearchView.SavedState{"
                    + Integer.toHexString(System.identityHashCode(this))
                    + " isIconified=" + isIconified + "}";
        }

        public static final Parcelable.Creator<SavedState> CREATOR = ParcelableCompat.newCreator(
                new ParcelableCompatCreatorCallbacks<SavedState>() {
                    @Override
                    public SavedState createFromParcel(Parcel in, ClassLoader loader) {
                        return new SavedState(in, loader);
                    }

                    @Override
                    public SavedState[] newArray(int size) {
                        return new SavedState[size];
                    }
                });
    }

*/


/**
 * @hide @hide
 * @hide
 */
/*

    @RestrictTo(GROUP_ID)
    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {

            if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                return true;
            }
            else

            if (event.getAction() == KeyEvent.ACTION_UP) {


                    return true;
            }
        }
        return super.onKeyPreIme(keyCode, event);
    }

*/
//AppCompatAutoCompleteTextView

/** @hide */
//  @RestrictTo(GROUP_ID)

